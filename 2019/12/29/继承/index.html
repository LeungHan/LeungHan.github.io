<!DOCTYPE html><html data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>继承 | 特立独型</title><meta name="description" content="继承"><meta name="keywords" content="Java - Java基础"><meta name="author" content="特立独型"><meta name="copyright" content="特立独型"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="继承"><meta name="twitter:description" content="继承"><meta name="twitter:image" content="https://static01.imgkr.com/temp/9b7d276c9ecc42e78e9e5602f4a8abd2.jpg"><meta property="og:type" content="article"><meta property="og:title" content="继承"><meta property="og:url" content="leunghan.github.io/2019/12/29/%E7%BB%A7%E6%89%BF/"><meta property="og:site_name" content="特立独型"><meta property="og:description" content="继承"><meta property="og:image" content="https://static01.imgkr.com/temp/9b7d276c9ecc42e78e9e5602f4a8abd2.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="leunghan.github.io/2019/12/29/%E7%BB%A7%E6%89%BF/"><link rel="prev" title="接口、lambda表达式与内部类" href="/leunghan.github.io/2019/12/31/%E6%8E%A5%E5%8F%A3%E3%80%81lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E5%86%85%E9%83%A8%E7%B1%BB/"><link rel="next" title="对象与类" href="/leunghan.github.io/2019/12/27/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.1.1"></head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">特立独型</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">16</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">6</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">4</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#继承"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">继承</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#一、类、超类和子类"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">一、类、超类和子类</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-1-方法覆盖"><span class="toc_mobile_items-number">1.1.1.</span> <span class="toc_mobile_items-text">1.1 方法覆盖</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-2-子类构造器"><span class="toc_mobile_items-number">1.1.2.</span> <span class="toc_mobile_items-text">1.2 子类构造器</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-3-多态"><span class="toc_mobile_items-number">1.1.3.</span> <span class="toc_mobile_items-text">1.3 多态</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-4-方法调用"><span class="toc_mobile_items-number">1.1.4.</span> <span class="toc_mobile_items-text">1.4 方法调用</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-5-final类与方法"><span class="toc_mobile_items-number">1.1.5.</span> <span class="toc_mobile_items-text">1.5 final类与方法</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#二、Object类"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">二、Object类</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-1-equals方法"><span class="toc_mobile_items-number">1.2.1.</span> <span class="toc_mobile_items-text">2.1 equals方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-2-hashCode方法"><span class="toc_mobile_items-number">1.2.2.</span> <span class="toc_mobile_items-text">2.2 hashCode方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-3-toString方法"><span class="toc_mobile_items-number">1.2.3.</span> <span class="toc_mobile_items-text">2.3 toString方法</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#三、泛型数组列表"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">三、泛型数组列表</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#四、包装器与自动装箱"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text">四、包装器与自动装箱</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#五、参数数量可变方法"><span class="toc_mobile_items-number">1.5.</span> <span class="toc_mobile_items-text">五、参数数量可变方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#六、枚举类"><span class="toc_mobile_items-number">1.6.</span> <span class="toc_mobile_items-text">六、枚举类</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#七、反射"><span class="toc_mobile_items-number">1.7.</span> <span class="toc_mobile_items-text">七、反射</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#7-1-Class-类"><span class="toc_mobile_items-number">1.7.1.</span> <span class="toc_mobile_items-text">7.1 Class 类</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#7-1-1-toString方法"><span class="toc_mobile_items-number">1.7.1.1.</span> <span class="toc_mobile_items-text">7.1.1 toString方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#7-1-2-getName方法"><span class="toc_mobile_items-number">1.7.1.2.</span> <span class="toc_mobile_items-text">7.1.2 getName方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#7-1-3-toGenericString方法"><span class="toc_mobile_items-number">1.7.1.3.</span> <span class="toc_mobile_items-text">7.1.3 toGenericString方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#7-1-4-forName方法"><span class="toc_mobile_items-number">1.7.1.4.</span> <span class="toc_mobile_items-text">7.1.4 forName方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#7-1-5-newInstance方法"><span class="toc_mobile_items-number">1.7.1.5.</span> <span class="toc_mobile_items-text">7.1.5 newInstance方法</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#7-2-捕获异常"><span class="toc_mobile_items-number">1.7.2.</span> <span class="toc_mobile_items-text">7.2 捕获异常</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#参考资料"><span class="toc_mobile_items-number">1.8.</span> <span class="toc_mobile_items-text">参考资料</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#继承"><span class="toc-number">1.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、类、超类和子类"><span class="toc-number">1.1.</span> <span class="toc-text">一、类、超类和子类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-方法覆盖"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1 方法覆盖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-子类构造器"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2 子类构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-多态"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3 多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-方法调用"><span class="toc-number">1.1.4.</span> <span class="toc-text">1.4 方法调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-final类与方法"><span class="toc-number">1.1.5.</span> <span class="toc-text">1.5 final类与方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、Object类"><span class="toc-number">1.2.</span> <span class="toc-text">二、Object类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-equals方法"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1 equals方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-hashCode方法"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2 hashCode方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-toString方法"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3 toString方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、泛型数组列表"><span class="toc-number">1.3.</span> <span class="toc-text">三、泛型数组列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、包装器与自动装箱"><span class="toc-number">1.4.</span> <span class="toc-text">四、包装器与自动装箱</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、参数数量可变方法"><span class="toc-number">1.5.</span> <span class="toc-text">五、参数数量可变方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六、枚举类"><span class="toc-number">1.6.</span> <span class="toc-text">六、枚举类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#七、反射"><span class="toc-number">1.7.</span> <span class="toc-text">七、反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-Class-类"><span class="toc-number">1.7.1.</span> <span class="toc-text">7.1 Class 类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-1-toString方法"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">7.1.1 toString方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-2-getName方法"><span class="toc-number">1.7.1.2.</span> <span class="toc-text">7.1.2 getName方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-3-toGenericString方法"><span class="toc-number">1.7.1.3.</span> <span class="toc-text">7.1.3 toGenericString方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-4-forName方法"><span class="toc-number">1.7.1.4.</span> <span class="toc-text">7.1.4 forName方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-5-newInstance方法"><span class="toc-number">1.7.1.5.</span> <span class="toc-text">7.1.5 newInstance方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-捕获异常"><span class="toc-number">1.7.2.</span> <span class="toc-text">7.2 捕获异常</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考资料"><span class="toc-number">1.8.</span> <span class="toc-text">参考资料</span></a></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://static01.imgkr.com/temp/9b7d276c9ecc42e78e9e5602f4a8abd2.jpg)"><div id="post-info"><div id="post-title"><div class="posttitle">继承</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2019-12-29<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2021-06-21</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java/">Java</a></span><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><p>本文介绍面向对象程序设计的另外一个基本概念：继承。继承就是已存在的类就是复用（继承）这些类的方法和域，在此基础上，还可以添加一些新的方法和域，以满足新的需求。这是 Java 程序设计中的一项核心技术。 </p>
<a id="more"></a>

<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="一、类、超类和子类"><a href="#一、类、超类和子类" class="headerlink" title="一、类、超类和子类"></a>一、类、超类和子类</h2><p>Java中使用关键字<code>extends</code>表明正在构造的新类派生于一个已存在的类。 已存在的类称为<strong>超类</strong>、 <strong>基类</strong>或<strong>父类</strong>，新类称为<strong>子类</strong>、<strong>派生类</strong>或<strong>孩子类</strong>。 </p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">	<span class="comment">//添加方法和域</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">	<span class="comment">//添加方法和域</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>注意：Java只支持单继承，不支持多继承，但是Java支持多层继承。</p>
<h3 id="1-1-方法覆盖"><a href="#1-1-方法覆盖" class="headerlink" title="1.1 方法覆盖"></a>1.1 方法覆盖</h3><p>超类中的有些方法对子类并不一定适用。为此，需要提供一个新的方法来<strong>覆盖</strong>超类中的这个方法： </p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	System.out.println(<span class="string">"animal : eat"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	System.out.println(<span class="string">"cat : eat"</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eatTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.eat(); <span class="comment">// this 调用本类的方法</span></span><br><span class="line">        <span class="keyword">super</span>.eat(); <span class="comment">// super 调用父类的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendsDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Animal a = <span class="keyword">new</span> Animal();</span><br><span class="line">        a.eat();</span><br><span class="line">        Cat c = <span class="keyword">new</span> Cat();</span><br><span class="line">        c.eatTest();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>子类不能够直接地访问超类的私有域，为此可以使用特定的关键字<code>super</code>解决这个问题.在覆盖一个方法的时候，<strong>子类方法不能低于超类方法的可见性</strong>。特别是， 如果超类方法是<code>public</code>，子类方法一定要声明为<code>public</code>。 </p>
<h3 id="1-2-子类构造器"><a href="#1-2-子类构造器" class="headerlink" title="1.2 子类构造器"></a>1.2 子类构造器</h3><p>如果子类的构造器没有显式地调用超类的构造器，则将自动地调用超类默认（没有参数）的构造器。 如果超类没有不带参数的构造器， 并且在子类的构造器中又没有显式地调用超类的其他构造器，则Java编译器将报告错误。 </p>
<p>回忆一下，关键字<code>this</code>有两个用途：一是引用隐式参数；二是调用该类其他的构造器。同样，<code>super</code>关键字也有两个用途：一是调用<strong>超类</strong>的方法，二是调用<strong>超类</strong>的构造器。在调用构造器的时候， 这两个关键字的使用方式很相似。调用构造器的语句只能作为另一个构造器的<strong>第一条语句</strong>出现。 <strong>构造参数既可以传递给本类的其他构造器， 也可以传递给超类的构造器。</strong> </p>
<h3 id="1-3-多态"><a href="#1-3-多态" class="headerlink" title="1.3 多态"></a>1.3 多态</h3><p>一个对象变量可以指示多种实际类型的现象被称为<strong>多态</strong>。在运行时能够自动地选择调用哪个方法的现象称为<strong>动态绑定</strong>。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	System.out.println(<span class="string">"吃鱼"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	System.out.println(<span class="string">"吃骨头"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 多态形式，创建对象</span></span><br><span class="line">        Animal a1 = <span class="keyword">new</span> Cat();</span><br><span class="line">        <span class="comment">// 调用的是 Cat 的 eat</span></span><br><span class="line">        a1.eat();</span><br><span class="line">        <span class="comment">// 多态形式，创建对象</span></span><br><span class="line">        Animal a2 = <span class="keyword">new</span> Dog();</span><br><span class="line">        <span class="comment">// 调用的是 Dog 的 eat</span></span><br><span class="line">        a2.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>发生多态必须包括以下几个条件：1、继承或者实现抽象类、接口；2、父类引用指向子类对；3、方法重写</strong></p>
<h3 id="1-4-方法调用"><a href="#1-4-方法调用" class="headerlink" title="1.4 方法调用"></a>1.4 方法调用</h3><p>弄清楚如何在对象上应用方法调用非常重要，假设要调用<code>x.f(args)</code>隐式参数<code>x</code>声明为类<code>C</code>的一个对象。下面是调用过程的详细描述：</p>
<ol>
<li><p><strong>编译器査看对象的声明类型和方法名</strong><br>假设调用<code>x.f(args)</code>隐式参数<code>x</code>声明为类<code>C</code>的一个对象。需要注意的是：有可能存在多个名字为<code>f</code>，但参数类型不一样的方法。例如，可能存在方法<code>x.f(int)</code>和方法<code>x.f(String)</code>，<strong>编译器将会一一列举所有 C 类中名为 f 的方法和其超类中访问属性为<code>public</code>且名为<code>f</code>的方法（超类的私有方法不可访问）。</strong></p>
</li>
<li><p><strong>译器将査看调用方法时提供的参数类型 **<br>如果在所有名为<code>f</code>的方法中存在一个与提供的参数类型完全匹配，就选择这个方法。这个过程被称为</strong>重栽解析**。如果编译器没有找到与参数类型匹配的方法，或者发现经过类型转换后有多个方法与之匹配， 就会报告一个错误。</p>
</li>
<li><p><strong>静态绑定与动态绑定</strong><br>如果是<code>private</code>方法、<code>static</code>方法、<code>final</code>方法或者构造器， 那么编译器将可以准确地知道应该调用哪个方法， 我们将这种调用方式称为<strong>静态绑定</strong>。与此对应的是，调用的方法依赖于隐式参数的实际类型， 并且在运行时实现<strong>动态绑定</strong>。</p>
</li>
<li><p><strong>运行</strong><br>当程序运行，并且采用动态绑定调用方法时， 虚拟机一定调用与<code>x</code>所引用对象的实际类型最合适的那个类的方法。</p>
</li>
</ol>
<p>每次调用方法都要进行搜索，时间开销相当大，因此， 虚拟机预先为每个类创建了一个<strong>方法表</strong> 其中列出了所有方法的签名和实际调用的方法。这样一来，在真正调用方法的时候， 虚拟机仅查找这个表就行了。<strong>如果调用<code>super.f(param)</code>编译器将对隐式参数超类的方法表进行搜索。</strong></p>
<h3 id="1-5-final类与方法"><a href="#1-5-final类与方法" class="headerlink" title="1.5 final类与方法"></a>1.5 <code>final</code>类与方法</h3><p>如果在定义类的时候使用了<code>final</code>修饰符就表明这个类是<code>final</code>类，<code>final</code>类不允许被继承，类中的特定方法也可以被声明为<code>final</code>。如果这样做，子类就不能覆盖这个方法（<code>final</code>类中所有方法自动成为<code>final</code>方法）</p>
<p>域也可以被声明为<code>final</code>，对于<code>final</code>域来说，构造对象之后就不允许改变它们的值了。 不过， 如果将一个类声明为<code>final</code>，只有其中的方法自动地成为<code>final</code>，而<strong>不包括域</strong>。</p>
<h2 id="二、Object类"><a href="#二、Object类" class="headerlink" title="二、Object类"></a>二、Object类</h2><p>Object 类是Java中所有类的始祖， 在Java中每个类都是由它扩展而来的，如果没有明确地指出超类，Object就被认为是这个类的超类。</p>
<h3 id="2-1-equals方法"><a href="#2-1-equals方法" class="headerlink" title="2.1 equals方法"></a>2.1 equals方法</h3><p>Object 类中的<code>equals</code>方法用于检测一个对象是否等于另外一个对象。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Object中equals方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在Object类中，这个方法将判断两个对象是否具有<strong>相同的引用</strong>， 如果两个对象具有相同的引用， 它们一定是相等的。从这点上看，将其作为默认操作也是合乎情理的。然而，对于多数类来说， 这种判断并没有什么意义。 例如对于String类而言，两个中内容相等，就认为他们相等。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//String中重写equals方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断是否指向同一个对象</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断传入的类是否属于String</span></span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;		<span class="comment">//value为字符数组</span></span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="2-2-hashCode方法"><a href="#2-2-hashCode方法" class="headerlink" title="2.2 hashCode方法"></a>2.2 hashCode方法</h3><p>散列码(hash code)是由对象导出的一个整型值，如果<code>x</code>和<code>y</code>是两个不同的对象，<code>x.hashCode()</code>与<code>y.hashCode()</code>基本上不会相同，字符串的散列码是由内容导出的。 如果重新定义<code>equals</code>方法， 就必须重新定义<code>hashCode</code>方法， 如果<code>x.equals(y)</code>返回<code>true</code>, 那么<code>x.hashCode()</code>就必须与<code>y.hashCode()</code>具有相同的值。 </p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Object类中hashCode方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></div>

<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//String类中hashCode方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="2-3-toString方法"><a href="#2-3-toString方法" class="headerlink" title="2.3 toString方法"></a>2.3 toString方法</h3><p>在<code>Object</code>中还有一个重要的方法， 就是<code>toString</code>方法， 它用于返回表示对象值的字符串。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Object类中toString方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">"@"</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="三、泛型数组列表"><a href="#三、泛型数组列表" class="headerlink" title="三、泛型数组列表"></a>三、泛型数组列表</h2><p>在许多程序设计语言中， 特别是在C++语言中， 必须在编译时就确定整个数组的大小。程序员对此十分反感，在Java中，解决这个问题最简单的方法是使用Java中另外一个被称为ArrayList的类。它使用起来有点像数组，但在添加或删除元素时，具有<strong>自动调节数组容量</strong>的功能，而不需要为此编写任何代码。<br>ArrayList是一个采用类型参数的<strong>泛型类</strong>。为了指定数组列表保存的元素对象类型，需要用一对尖括号将类名括起来加在后面，例如，<code>ArrayList&lt;Person&gt;</code>。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个返校list</span></span><br><span class="line">ArrayList&lt;Person&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure></div>

<h2 id="四、包装器与自动装箱"><a href="#四、包装器与自动装箱" class="headerlink" title="四、包装器与自动装箱"></a>四、包装器与自动装箱</h2><p>有时，需要将<code>int</code>这样的基本类型转换为对象。 所有的基本类型都冇一个与之对应的类。例如<code>Integer</code>类对应基本类型<code>int</code>。通常， 这些类称为<strong>包装器</strong>这些对象包装器类拥有很明显的名字：<code>Integer</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>、<code>Short</code>、<code>Byte</code>、<code>Character</code>、 <code>Void</code>和<code>Boolean</code> (前6个类派生于公共的超类 Number)。<strong>对象包装器类是不可变的</strong>，即一旦构造了包装器，就不允许更改包装在其中的值。同时， <strong>对象包装器类还是<code>final</code></strong>, 因此不能定义它们的子类。</p>
<p>如果想定义一个整型数组列表，而泛型中的类型参数不允许是基本类型，可以通过<code>Integer</code>对象包装器类实现。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;()；</span><br></pre></td></tr></table></figure></div>
<p>在Java SE5中，为了减少开发人员的工作，Java提供了<strong>自动装箱</strong>与<strong>自动拆箱</strong>功能。</p>
<ul>
<li>自动装箱: 就是将基本数据类型自动转换成对应的包装类，<code>list.add(3);</code>会自动转换为<code>list.add(Integer.value0f(3));</code></li>
<li>自动拆箱：就是将包装类自动转换成对应的基本数据类型，<code>int n = list.get(i);</code>会被翻译为<code>int n = list.get(i).intValue();</code></li>
</ul>
<p>另外，如果在一个条件表达式中混合使用<code>Integer</code>和<code>Double</code>类型，<code>Integer</code>值就会拆箱，提升为<code>double</code>再装箱为 <code>Double</code>。 </p>
<h2 id="五、参数数量可变方法"><a href="#五、参数数量可变方法" class="headerlink" title="五、参数数量可变方法"></a>五、参数数量可变方法</h2><p>在Java SE 5.0以前的版本中，每个Java方法都有固定数量的参数。然而，现在的版本提供了可以用可变的参数数量调用的方法，例如<code>System.out.printfrxd&quot;, n);</code>和<code>System.out.printf(&quot;Xd %s\ n, &quot;widgets&quot;);</code>。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//printf的源码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PrintStream <span class="title">printf</span><span class="params">(String format, Object ... args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> format(format, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这里的省略号<code>...</code>是 Java 代码的一部分，它表明这个方法可以接收任意数量的对象（除<code>fmt</code>参数之外。实际上，<code>printf</code>方法接收两个参数， 一个是格式字符串， 另一个是<code>Object[]</code>数组， 其中保存着所有的参数，现在将扫描<code>fmt</code>字符串， 并将第 i 个格式说明符与<code>args[i]</code>的值匹配起来。</p>
<h2 id="六、枚举类"><a href="#六、枚举类" class="headerlink" title="六、枚举类"></a>六、枚举类</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个枚举类</span></span><br><span class="line"><span class="keyword">public</span> enuni Size &#123; SMALL, MEDIUM, LARGE, EXTRAJARGE &#125;;</span><br></pre></td></tr></table></figure></div>
<p>如果需要的话，可以在枚举类型中添加一些构造器、方法和域。当然，构造器只是在构造枚举常量的时候被调用。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Size</span><br><span class="line">&#123;</span><br><span class="line">    SMALL(<span class="string">"S"</span>), MEDIUM(<span class="string">"M"</span>), LARGE(<span class="string">"L"</span>), EXTRA_LARGE(<span class="string">"XL"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String abbreviation;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Size</span><span class="params">(String abbreviation)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.abbreviation = abbreviation;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAbbreviation</span><span class="params">()</span></span>&#123; </span><br><span class="line">        <span class="keyword">return</span> abbreviation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>所有的枚举类型都是<code>Enum</code>类的子类。它们继承了这个类的许多方法。其中最有用的一个是 <code>toString</code>，这个方法能够返回枚举常量名。例如，<code>Size.SMALL.toString()</code>将返回字符串<code>SMALL</code>。</p>
<h2 id="七、反射"><a href="#七、反射" class="headerlink" title="七、反射"></a>七、反射</h2><p>反射库提供了一个非常丰富且精心设计的工具集， 以便编写能够动态操纵 Java 代码的程序。</p>
<h3 id="7-1-Class-类"><a href="#7-1-Class-类" class="headerlink" title="7.1 Class 类"></a>7.1 Class 类</h3><p>在程序运行期间，Java运行时系统始终为所有的对象维护一个被称为运行时的类型标识，这个信息跟踪着每个对象所属的类， 虚拟机利用运行时类型信息选择相应的方法执行，通过专门的Java类访问这些信息，<strong>保存这些信息的类被称为<code>Class</code></strong>。<code>Object</code>类中的<code>getClass()</code>方法将会返回一个<code>Class</code>类型的实例。下面简单看一下<code>Class</code>类都包括哪些方法</p>
<h4 id="7-1-1-toString方法"><a href="#7-1-1-toString方法" class="headerlink" title="7.1.1 toString方法"></a>7.1.1 toString方法</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (isInterface() ? <span class="string">"interface "</span> : (isPrimitive() ? <span class="string">""</span> : <span class="string">"class "</span>))</span><br><span class="line">    + getName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><code>toString()</code>方法能够将对象转换为字符串，<code>toString()</code>首先会判断<code>Class</code>类型是否是接口类型，也就是说普通类和接口都能用<code>Class</code>对象来表示，然后在判断是否是基本数据类型，这里判断的都是基本数据类型和包装类以及<code>void</code>类型。</p>
<h4 id="7-1-2-getName方法"><a href="#7-1-2-getName方法" class="headerlink" title="7.1.2 getName方法"></a>7.1.2 getName方法</h4><p><code>getName()</code>方法返回类的全限定类名</p>
<ul>
<li>引用数据类型，比如<code>String.class.getName()</code> -&gt; <code>java.lang.String</code></li>
<li>基本数据类型，比如<code>byte.class.getName()</code> -&gt; <code>byte</code></li>
<li>数组数据类型，比如<code>new Object[3].getClass().getName()</code> -&gt; <code>java.lang.Object</code></li>
</ul>
<h4 id="7-1-3-toGenericString方法"><a href="#7-1-3-toGenericString方法" class="headerlink" title="7.1.3 toGenericString方法"></a>7.1.3 toGenericString方法</h4><p>这个方法会返回类的全限定名称，包括累的修饰符和类型参数信息</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//public final class java.lang.String</span></span><br><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"test"</span>);</span><br><span class="line">System.out.println(str.getClass().toGenericString());</span><br></pre></td></tr></table></figure></div>

<h4 id="7-1-4-forName方法"><a href="#7-1-4-forName方法" class="headerlink" title="7.1.4 forName方法"></a>7.1.4 forName方法</h4><p>根据类名获得一个<code>Class</code>对象的引用，通过<code>Class t1 = Class.forName(&quot;java.lang.Thread&quot;)</code>，能初始化一个Thread的线程对象，在Java中有种获取<code>Class</code>的方式有三种</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//class com.leunghan.test</span></span><br><span class="line">Class&lt;?&gt; c1 = Class.forName(<span class="string">"com.leunghan.test"</span>);</span><br><span class="line">System.out.println(c1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//class com.leunghan.test</span></span><br><span class="line">System.out.println(test<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//class com.leunghan.test</span></span><br><span class="line">test t2 = <span class="keyword">new</span> test();</span><br><span class="line">System.out.println(t2.getClass());</span><br></pre></td></tr></table></figure></div>
<h4 id="7-1-5-newInstance方法"><a href="#7-1-5-newInstance方法" class="headerlink" title="7.1.5 newInstance方法"></a>7.1.5 newInstance方法</h4><p>创建一个类的实例，代表这个类的对象，上面的<code>forName</code>方法对类进行初始化，<code>newInstance</code>方法对这个类进行实例化。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//class java.lang.String</span></span><br><span class="line">String str = String<span class="class">.<span class="keyword">class</span>.<span class="title">newInstance</span>()</span>;</span><br><span class="line">System.out.println(str.getClass());</span><br></pre></td></tr></table></figure></div>

<p><code>Class</code>类中的<code>getFields</code>、<code>getMethods</code>和<code>getConstructors</code>方 法 将 分 别 返 回 类 提 供 的<code>public</code>域、 方法和构造器数组， 其中包括超类的公有成员。</p>
<h3 id="7-2-捕获异常"><a href="#7-2-捕获异常" class="headerlink" title="7.2 捕获异常"></a>7.2 捕获异常</h3><p>当程序运行过程中发生错误时，就会“抛出异常”，抛出异常比终止程序要灵活得多，这是因为可以提供一个“捕获”异常的处理器对异常情况进行处理，如果没有提供处理器，程序就会终止，并在控制台上打印出一条信息，其中给出了异常的类型。<br>异常有两种类型： 未检查异常和已检查异常。 对于已检查异常， 编译器将会检查是否提供了处理器。将可能抛出已检査异常的一个或多个方法调用代码放在<code>try</code>块中，然后在<code>catch</code>子句中提供处理器代码。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    String name = . . .; 				<span class="comment">// get class name</span></span><br><span class="line">    Class cl = Class.forName(name) ; 	<span class="comment">// might throw exception</span></span><br><span class="line">    <span class="comment">//dosomething with c1</span></span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">	e.printStackTraceO ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] Cay S Horstmann. Java核心技术 卷1 基础知识(原书第10版)[M]. 机械工业出版社出版社, 2016.</p>
</div></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java-Java%E5%9F%BA%E7%A1%80/">Java - Java基础    </a></div><div class="post_share"></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2019/12/31/%E6%8E%A5%E5%8F%A3%E3%80%81lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E5%86%85%E9%83%A8%E7%B1%BB/"><img class="prev_cover lazyload" data-src="https://static01.imgkr.com/temp/9b7d276c9ecc42e78e9e5602f4a8abd2.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>接口、lambda表达式与内部类</span></div></a></div><div class="next-post pull_right"><a href="/2019/12/27/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/"><img class="next_cover lazyload" data-src="https://static01.imgkr.com/temp/9b7d276c9ecc42e78e9e5602f4a8abd2.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>对象与类</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> Recommend</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/12/22/Java的基本程序设计结构/" title="Java的基本程序设计结构"><img class="relatedPosts_cover lazyload"data-src="https://static01.imgkr.com/temp/9b7d276c9ecc42e78e9e5602f4a8abd2.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-06-23</div><div class="relatedPosts_title">Java的基本程序设计结构</div></div></a></div><div class="relatedPosts_item"><a href="/2019/12/27/对象与类/" title="对象与类"><img class="relatedPosts_cover lazyload"data-src="https://static01.imgkr.com/temp/9b7d276c9ecc42e78e9e5602f4a8abd2.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-06-23</div><div class="relatedPosts_title">对象与类</div></div></a></div><div class="relatedPosts_item"><a href="/2019/12/31/接口、lambda表达式与内部类/" title="接口、lambda表达式与内部类"><img class="relatedPosts_cover lazyload"data-src="https://static01.imgkr.com/temp/9b7d276c9ecc42e78e9e5602f4a8abd2.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-06-23</div><div class="relatedPosts_title">接口、lambda表达式与内部类</div></div></a></div></div><div class="clear_both"></div></div></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By 特立独型</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="/js/tw_cn.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>